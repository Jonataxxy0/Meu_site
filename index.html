<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo Misterioso Clássico</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }

        #gameCanvas {
            background-color: #111;
            border: 4px solid #fff;
            cursor: none; /* O cursor será substituído pela raquete */
        }

        #scoreBoard {
            margin: 15px 0;
            font-size: 2em;
        }

        #instructions {
            margin-top: 10px;
            color: #ccc;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: limegreen;
            text-shadow: 0 0 10px #0f0;
            z-index: 10;
            user-select: none;
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>

    <h1>Jogo Clássico Misterioso</h1>

    <div id="scoreBoard">0</div>
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    <div id="instructions">Mova o mouse para controlar o bloco inferior.</div>
    <div id="message"></div>

    <script>
        // --- Configurações do Canvas e Contexto ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('scoreBoard');
        const messageDisplay = document.getElementById('message');

        // --- Variáveis do Jogo ---
        const gameWidth = canvas.width;
        const gameHeight = canvas.height;

        let score = 0;
        let lives = 3;
        let gameLoop;
        let isRunning = false;
        let isPaused = true;

        // --- Configurações da Bola ---
        let ball = {
            x: gameWidth / 2,
            y: gameHeight / 2,
            radius: 8,
            speed: 5,
            dx: 5, // Velocidade X
            dy: -5  // Velocidade Y (começa subindo)
        };

        // --- Configurações da Raquete (Paddle) ---
        let paddle = {
            height: 10,
            width: 75,
            x: (gameWidth - 75) / 2 // Posição inicial centralizada
        };

        // --- Configurações dos Blocos (Tijolos) ---
        const brickInfo = {
            width: 75,
            height: 20,
            padding: 10,
            offsetTop: 30,
            offsetLeft: 30,
            visible: true
        };

        const brickRowCount = 5;
        const brickColumnCount = 6;
        const bricks = [];

        // Inicializa a matriz de blocos
        function initBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    const x = c * (brickInfo.width + brickInfo.padding) + brickInfo.offsetLeft;
                    const y = r * (brickInfo.height + brickInfo.padding) + brickInfo.offsetTop;
                    bricks[c][r] = { x, y, ...brickInfo };
                }
            }
        }

        // --- Funções de Desenho ---

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#eee';
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.fillStyle = 'cyan';
            ctx.fillRect(paddle.x, gameHeight - paddle.height - 5, paddle.width, paddle.height);
        }

        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const brick = bricks[c][r];
                    if (brick.visible) {
                        ctx.fillStyle = `hsl(${r * 30 + c * 10}, 80%, 50%)`; // Cores Variadas
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                        ctx.strokeStyle = '#000';
                        ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                    }
                }
            }
        }

        // --- Funções de Movimento e Colisão ---

        function moveBall() {
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Colisão com as Paredes (Esquerda/Direita)
            if (ball.x + ball.radius > gameWidth || ball.x - ball.radius < 0) {
                ball.dx *= -1; // Inverte direção X
            }

            // Colisão com o Teto
            if (ball.y - ball.radius < 0) {
                ball.dy *= -1; // Inverte direção Y
            }

            // Colisão com o Chão (Perde Vida)
            if (ball.y + ball.radius > gameHeight) {
                lives--;
                if (lives === 0) {
                    endGame("Game Over!");
                } else {
                    resetBallAndPaddle();
                }
            }

            // Colisão com a Raquete
            if (ball.y + ball.radius > gameHeight - paddle.height - 5 &&
                ball.x > paddle.x &&
                ball.x < paddle.x + paddle.width &&
                ball.dy > 0 // Apenas se estiver caindo
            ) {
                ball.dy *= -1;
            }

            // Colisão com os Blocos
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const brick = bricks[c][r];

                    if (brick.visible) {
                        if (
                            ball.x - ball.radius < brick.x + brick.width && // Lado Esquerdo da Bola
                            ball.x + ball.radius > brick.x &&             // Lado Direito da Bola
                            ball.y - ball.radius < brick.y + brick.height && // Parte Superior da Bola
                            ball.y + ball.radius > brick.y                  // Parte Inferior da Bola
                        ) {
                            ball.dy *= -1; // Inverte a direção vertical
                            brick.visible = false;
                            increaseScore();
                        }
                    }
                }
            }
        }

        // --- Funções de Estado do Jogo ---

        function increaseScore() {
            score++;
            scoreBoard.textContent = score;

            // Checar se todos os blocos foram quebrados
            let bricksLeft = false;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].visible) {
                        bricksLeft = true;
                        break;
                    }
                }
                if (bricksLeft) break;
            }

            if (!bricksLeft) {
                endGame("Vitória! Próxima Fase!");
                // Simplesmente reinicia o jogo, mas você poderia aumentar a dificuldade aqui
            }
        }

        function draw() {
            // Limpa o Canvas
            ctx.clearRect(0, 0, gameWidth, gameHeight);

            drawBall();
            drawPaddle();
            drawBricks();

            // Adiciona informações de vidas na tela
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.fillText(`Vidas: ${lives}`, gameWidth - 80, gameHeight - 10);
        }

        function updateGame() {
            if (isPaused) return;

            moveBall();
            draw();

            // O requestAnimationFrame permite um loop de animação mais suave e eficiente
            if (isRunning) {
                requestAnimationFrame(updateGame);
            }
        }

        function resetBallAndPaddle() {
            isPaused = true;
            ball.x = gameWidth / 2;
            ball.y = gameHeight / 2;
            ball.dx = 5;
            ball.dy = -5;
            paddle.x = (gameWidth - paddle.width) / 2;

            messageDisplay.textContent = `Clique para começar (Vidas: ${lives})`;
            messageDisplay.style.display = 'block';
        }

        function startGame() {
            if (isRunning) return;
            
            // Estado inicial completo
            score = 0;
            lives = 3;
            scoreBoard.textContent = '0';
            initBricks();
            
            messageDisplay.style.display = 'none';
            isRunning = true;
            resetBallAndPaddle(); // Prepara o estado
            
            // O jogo realmente começa no primeiro clique
        }

        function resumeGame() {
             if (isRunning && isPaused) {
                isPaused = false;
                messageDisplay.style.display = 'none';
                updateGame();
            }
        }

        function endGame(msg) {
            isRunning = false;
            messageDisplay.textContent = msg;
            messageDisplay.style.display = 'block';
            messageDisplay.onclick = startGame; // Permite reiniciar clicando na mensagem
        }

        // --- Event Listeners ---

        // Controla a raquete com o movimento do mouse
        canvas.addEventListener('mousemove', (e) => {
            const relativeX = e.clientX - canvas.getBoundingClientRect().left;
            
            if (relativeX > 0 && relativeX < gameWidth) {
                // Centraliza a raquete onde o mouse está, mantendo-a dentro dos limites
                paddle.x = Math.min(gameWidth - paddle.width, Math.max(0, relativeX - paddle.width / 2));
            }
        });

        // Inicia/Continua o jogo ao clicar
        canvas.addEventListener('click', resumeGame);

        // --- Inicia a Configuração Inicial ---
        startGame();
    </script>
</body>
</html>
