<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ping Pong com F√≠sica</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #0d1a26; /* Azul Escuro */
            color: white;
            font-family: 'Consolas', monospace;
            margin: 0;
            padding: 20px;
        }

        h1 {
            color: #2ecc71;
        }

        #gameCanvas {
            background-color: #1a334d; /* Cor da mesa */
            border: 4px solid #f39c12; /* Borda laranja/mesa */
        }

        #scoreBoard {
            margin: 15px 0;
            font-size: 2.5em;
            color: #ecf0f1;
        }

        #message {
            margin-top: 10px;
            font-size: 1.5em;
            color: #e74c3c;
            height: 30px;
        }
        
        .restart-btn {
            padding: 10px 20px;
            font-size: 1.2em;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        .restart-btn:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>

    <h1>üèì Ping Pong com F√≠sica</h1>

    <div id="scoreBoard">Jogador 0 - 0 Computador</div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="message">Clique para Iniciar</div>
    <button class="restart-btn" onclick="startGame()">Reiniciar</button>

    <script>
        // --- 1. Configura√ß√£o do Canvas e Contexto ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('scoreBoard');
        const messageDisplay = document.getElementById('message');

        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;

        // --- 2. Vari√°veis de Jogo e F√≠sica ---
        
        // Objeto da Bola
        let ball = {
            x: GAME_WIDTH / 2,
            y: GAME_HEIGHT / 2,
            radius: 8,
            speed: 5, // Velocidade base (m√≠nima)
            maxSpeed: 15, // Limite de velocidade para o realismo
            velocityX: 0,
            velocityY: 0
        };

        // Raquete do Jogador (Esquerda)
        let player = {
            width: 10,
            height: 80,
            x: 10,
            y: (GAME_HEIGHT - 80) / 2,
            score: 0,
            speed: 10 // Velocidade de movimento da raquete
        };

        // Raquete do Computador (Direita)
        let computer = {
            width: 10,
            height: 80,
            x: GAME_WIDTH - 20,
            y: (GAME_HEIGHT - 80) / 2,
            score: 0,
            speed: 6 // Velocidade do movimento da IA (deve ser menor que a do jogador)
        };

        let keys = {};
        let gameLoop;
        let isPaused = true;

        // --- 3. Fun√ß√µes de Desenho ---

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
        }

        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
        }

        function drawNet() {
            // Linha Central Pontilhada
            for (let i = 0; i < GAME_HEIGHT; i += 15) {
                drawRect(GAME_WIDTH / 2 - 1, i, 2, 8, '#ccc');
            }
        }

        function drawGame() {
            // Fundo
            drawRect(0, 0, GAME_WIDTH, GAME_HEIGHT, '#1a334d');
            
            // Rede (Net)
            drawNet();

            // Raquetes
            drawRect(player.x, player.y, player.width, player.height, '#2ecc71');
            drawRect(computer.x, computer.y, computer.width, computer.height, '#e74c3c');

            // Bola
            drawCircle(ball.x, ball.y, ball.radius, '#f1c40f');
        }

        // --- 4. L√≥gica de Colis√£o e Movimento (O Realismo) ---

        function movePaddle() {
            // Movimento do Jogador (Setas ou W/S)
            if ((keys['ArrowUp'] || keys['w'] || keys['W']) && player.y > 0) {
                player.y -= player.speed;
            } else if ((keys['ArrowDown'] || keys['s'] || keys['S']) && player.y < GAME_HEIGHT - player.height) {
                player.y += player.speed;
            }
        }

        function moveComputer() {
            // IA Simples: Segue a bola, mas com uma velocidade limitada (para n√£o ser perfeita)
            let targetY = ball.y - computer.height / 2;
            
            if (computer.y < targetY) {
                computer.y = Math.min(computer.y + computer.speed, GAME_HEIGHT - computer.height);
            } else if (computer.y > targetY) {
                computer.y = Math.max(computer.y - computer.speed, 0);
            }
        }

        function collisionDetection(b, p) {
            // Colis√£o AABB simples
            return b.x + b.radius > p.x &&
                   b.x - b.radius < p.x + p.width &&
                   b.y + b.radius > p.y &&
                   b.y - b.radius < p.y + p.height;
        }

        function handleCollision(paddle) {
            // 1. Calcula a Posi√ß√£o Relativa de Toque na Raquete
            // Onde na raquete a bola tocou (0 = topo, 1 = base)
            let collidePoint = ball.y - (paddle.y + paddle.height / 2);
            collidePoint = collidePoint / (paddle.height / 2); // Normaliza entre -1 e 1

            // 2. Calcula o √Çngulo de Rebatida
            // Quanto mais perto da extremidade, mais inclinado (mais efeito)
            const angle = collidePoint * Math.PI / 4; // √Çngulo m√°ximo de 45 graus (PI/4)

            // 3. Acelera a Bola (Aumenta o Realismo/Dificuldade)
            ball.speed = Math.min(ball.maxSpeed, ball.speed + 1.5);

            // 4. Aplica Nova Velocidade
            // O sinal do paddle.x determina se a bola deve ir para direita (1) ou esquerda (-1)
            const direction = (paddle === player) ? 1 : -1; 
            
            ball.velocityX = direction * ball.speed * Math.cos(angle);
            ball.velocityY = ball.speed * Math.sin(angle);
        }

        function resetBall(direction) {
            // Resetar a bola ap√≥s um ponto ser marcado
            ball.x = GAME_WIDTH / 2;
            ball.y = GAME_HEIGHT / 2;
            ball.speed = 5; 
            
            // Inicia a bola em dire√ß√£o ao jogador que perdeu o ponto
            const startAngle = (Math.random() * (Math.PI/2)) - (Math.PI/4); // √Çngulo aleat√≥rio entre -45 e +45 graus
            ball.velocityX = direction * ball.speed * Math.cos(startAngle);
            ball.velocityY = ball.speed * Math.sin(startAngle);
            
            // Pausa at√© o pr√≥ximo clique
            isPaused = true;
            messageDisplay.textContent = 'Ponto! Clique para sacar.';
        }

        function updateGame() {
            if (isPaused) return;

            // 1. Movimento da Bola
            ball.x += ball.velocityX;
            ball.y += ball.velocityY;

            // 2. Colis√£o com as Paredes Superior/Inferior
            if (ball.y + ball.radius > GAME_HEIGHT || ball.y - ball.radius < 0) {
                ball.velocityY *= -1;
            }

            // 3. Colis√£o com o GOL (Pontua√ß√£o)
            if (ball.x - ball.radius < 0) {
                // Ponto para o Computador (Saiu pela esquerda)
                computer.score++;
                scoreBoard.textContent = `Jogador ${player.score} - ${computer.score} Computador`;
                resetBall(-1); // Reseta a bola em dire√ß√£o ao perdedor (jogador)
                return;
            } else if (ball.x + ball.radius > GAME_WIDTH) {
                // Ponto para o Jogador (Saiu pela direita)
                player.score++;
                scoreBoard.textContent = `Jogador ${player.score} - ${computer.score} Computador`;
                resetBall(1); // Reseta a bola em dire√ß√£o ao perdedor (computador)
                return;
            }

            // 4. Colis√£o com Raquetes
            let paddle = (ball.x < GAME_WIDTH / 2) ? player : computer;
            
            if (collisionDetection(ball, paddle)) {
                handleCollision(paddle);
            }
            
            // 5. Movimento das Raquetes
            movePaddle();
            moveComputer();

            drawGame();
            requestAnimationFrame(updateGame);
        }

        // --- 5. Fun√ß√µes de Controle ---

        function startGame() {
            player.score = 0;
            computer.score = 0;
            scoreBoard.textContent = `Jogador 0 - 0 Computador`;
            
            player.y = (GAME_HEIGHT - player.height) / 2;
            computer.y = (GAME_HEIGHT - computer.height) / 2;

            // Inicia o saque aleatoriamente
            resetBall(Math.random() < 0.5 ? 1 : -1); 
            
            messageDisplay.textContent = 'Clique para sacar.';
            drawGame();
        }
        
        function resumeGame(event) {
            // S√≥ resume se o clique estiver dentro da √°rea de jogo
            if (isPaused && event.target === canvas) {
                isPaused = false;
                messageDisplay.textContent = '';
                requestAnimationFrame(updateGame);
            }
        }

        // --- 6. Event Listeners ---
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Clique no Canvas para sacar
        canvas.addEventListener('click', resumeGame);

        // Inicializa o jogo ao carregar a p√°gina
        startGame();
    </script>
</body>
</html>
